"use strict";(self.webpackChunkyui_docs_yui_ibc_solidity=self.webpackChunkyui_docs_yui_ibc_solidity||[]).push([[295],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return k}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=a.createContext({}),s=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=s(e.components);return a.createElement(c.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=s(t),m=r,k=d["".concat(c,".").concat(m)]||d[m]||p[m]||o;return t?a.createElement(k,i(i({ref:n},u),{},{components:t})):a.createElement(k,i({ref:n},u))}));function k(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=m;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[d]="string"==typeof e?e:r,i[1]=l;for(var s=2;s<o;s++)i[s]=t[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},1900:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return i},default:function(){return p},frontMatter:function(){return o},metadata:function(){return l},toc:function(){return s}});var a=t(3117),r=(t(7294),t(3905));const o={sidebar_position:3},i="Create a contract",l={unversionedId:"minitoken/contract",id:"minitoken/contract",title:"Create a contract",description:"We will implement a token that can be transferred between two ledgers using IBC.",source:"@site/docs/minitoken/contract.md",sourceDirName:"minitoken",slug:"/minitoken/contract",permalink:"/yui-docs/yui-ibc-solidity/minitoken/contract",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Required preparations in advance",permalink:"/yui-docs/yui-ibc-solidity/minitoken/prerequisites"},next:{title:"Deploy contracts",permalink:"/yui-docs/yui-ibc-solidity/minitoken/deploy"}},c={},s=[{value:"Basic Functions",id:"basic-functions",level:2},{value:"constructor",id:"constructor",level:3},{value:"mint",id:"mint",level:3},{value:"burn",id:"burn",level:3},{value:"transfer",id:"transfer",level:3},{value:"balanceOf",id:"balanceof",level:3},{value:"IBC-related",id:"ibc-related",level:2},{value:"Packet",id:"packet",level:3},{value:"Modify constructor",id:"modify-constructor",level:3},{value:"sendTransfer",id:"sendtransfer",level:3},{value:"IBCAppBase",id:"ibcappbase",level:3},{value:"onRecvPacket",id:"onrecvpacket",level:4},{value:"onAcknowledgementPacket",id:"onacknowledgementpacket",level:4},{value:"Topics that were not dealt with here",id:"topics-that-were-not-dealt-with-here",level:2},{value:"Distinction between currency units",id:"distinction-between-currency-units",level:3}],u={toc:s},d="wrapper";function p(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"create-a-contract"},"Create a contract"),(0,r.kt)("p",null,"We will implement a token that can be transferred between two ledgers using IBC."),(0,r.kt)("p",null,"There is a token transfer standard called ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc/tree/main/spec/app/ics-020-fungible-token-transfer"},"ICS-20"),",\nbut we do not support the standard here."),(0,r.kt)("p",null,"While ICS-20 uses denomination to distinguish the source ledger,\nthe MiniToken implemented here handles the issuer's ledger without distinction."),(0,r.kt)("h2",{id:"basic-functions"},"Basic Functions"),(0,r.kt)("p",null,"It has the following basic operational functions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"mint"),": issue a new token for a given account"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"burn"),": burn your own token"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"transfer"),": Transfer your token to another account.")),(0,r.kt)("p",null,"It also has a state reference function:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"balanceOf"),": to get the token balance of an account.")),(0,r.kt)("p",null,"The following states are also available:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"balances"),": accounts and their respective token balances"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"owner"),": An account that is allowed to perform privileged operations such as mint.")),(0,r.kt)("h3",{id:"constructor"},"constructor"),(0,r.kt)("p",null,"In this example, we simply use the account that generated the contract as the owner."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="contracts/app/MiniToken.sol"',title:'"contracts/app/MiniToken.sol"'},"address private owner;\n\nconstructor() {\n    owner = msg.sender;\n}\n")),(0,r.kt)("h3",{id:"mint"},"mint"),(0,r.kt)("p",null,"Increments the token by the specified amount for the specified account.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"_mint")," is defined because we want to call the logic later from other internal processes."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'mapping(address => uint256) private _balances;\n\nfunction mint(address account, uint256 amount) onlyOwner external {\n    require(_mint(account, amount), "invalid address");\n}\n\nfunction _mint(address account, uint256 amount) internal returns (bool) {\n    if (account == address(0)) {\n        return false;\n    }\n    _balances[account] += amount;\n    return true;\n}\n')),(0,r.kt)("p",null,"We won't cover the description of modifier implementations such as ",(0,r.kt)("inlineCode",{parentName:"p"},"onlyOwner"),", so please refer to the source code if you are interested."),(0,r.kt)("h3",{id:"burn"},"burn"),(0,r.kt)("p",null,"Reduces tokens by the specified amount for the specified account."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function burn(address account, uint256 amount) onlyOwner external {\n    _burn(account, amount);\n}\n\nfunction _burn(address account, uint256 amount) internal returns (bool) {\n    uint256 accountBalance = _balances[account];\n    if (accountBalance < amount) {\n        return false;\n    }\n    _balances[account] = accountBalance - amount;\n    return true;\n}\n")),(0,r.kt)("h3",{id:"transfer"},"transfer"),(0,r.kt)("p",null,"Sends some tokens to another account."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'function transfer(address to, uint256 amount) external {\n    require(to != address(0), "Token: invalid address");\n    uint256 balance = _balances[msg.sender];\n    require(_balances[msg.sender] >= amount, "Token: amount shortage");\n    _balances[msg.sender] -= amount;\n    _balances[to] += amount;\n}\n')),(0,r.kt)("h3",{id:"balanceof"},"balanceOf"),(0,r.kt)("p",null,"Returns the balance of an account."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'function balanceOf(address account) external view returns (uint256) {\n    require(account != address(0), "Token: invalid address");\n    return _balances[account];\n}\n')),(0,r.kt)("h2",{id:"ibc-related"},"IBC-related"),(0,r.kt)("p",null,"Based on the above functions, we will implement the necessary processes for IBC."),(0,r.kt)("h3",{id:"packet"},"Packet"),(0,r.kt)("p",null,"Define an IBC Packet to be used for communication between ledgers."),(0,r.kt)("p",null,"If you want to know more about Packet, please refer to ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc/tree/main/spec/core/ics-004-channel-and-packet-semantics"},"ICS 004"),"\nfor more information."),(0,r.kt)("p",null,"MiniTokenPacketData holds the information necessary to transfer a MiniToken from the source ledger to the destination ledger."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-proto",metastring:'title="/proto/lib/Packet.proto"',title:'"/proto/lib/Packet.proto"'},"message MiniTokenPacketData {\n    // the token amount to be transferred\n    uint64 amount = 1;\n    // the sender address\n    bytes sender = 2;\n    // the recipient address on the destination chain\n    bytes receiver = 3;\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"amount: amount of tokens to send"),(0,r.kt)("li",{parentName:"ul"},"sender: the source account in the source ledger"),(0,r.kt)("li",{parentName:"ul"},"receiver: the destination account in the destination ledger")),(0,r.kt)("p",null,"Once you have defined the Packet\nUse ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/datachainlab/solidity-protobuf"},"solidity-protobuf")," to generate the sol file."),(0,r.kt)("p",null,"First, get solidity-protobuf and install the necessary modules.\nFor details on the revision specified by yui-ibc-solidity, please refer to the following:"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/hyperledger-labs/yui-ibc-solidity/tree/v0.3.14#for-developers"},"https://github.com/hyperledger-labs/yui-ibc-solidity/tree/v0.3.14#for-developers")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"git clone https://github.com/datachainlab/solidity-protobuf.git\ncd solidity-protobuf\ngit checkout fce34ce0240429221105986617f64d8d4261d87d\npip install -r requirements.txt\n")),(0,r.kt)("p",null,"Then, on the working directory of the tutorial, generate the sol file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"cd <tutorial dir>\nmake SOLPB_DIR=/path/to/solidity-protobuf proto-sol\n")),(0,r.kt)("h3",{id:"modify-constructor"},"Modify constructor"),(0,r.kt)("p",null,'As a contract of the IBC/TAO layer defined by yui-ibc-solidity, the following can be specified in MiniToken.\nThe TAO layer represents "transport, authentication, & ordering" and handles core IBC functions independent of the application logic.'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"IBCHandler")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"IBCHandler ibcHandler;\n\nconstructor(IBCHandler ibcHandler_) {\n    owner = msg.sender;\n    ibcHandler = ibcHandler_;\n}\n")),(0,r.kt)("h3",{id:"sendtransfer"},"sendTransfer"),(0,r.kt)("p",null,"Adds a new manipulation function for Token.\nWe will add a new manipulation function for Token.\n",(0,r.kt)("inlineCode",{parentName:"p"},"sendTransfer")," is a method to send a token to the other party's ledger using the MiniTokenPacketData that we defined earlier."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function sendTransfer(\n    string calldata denom,\n    uint64 amount,\n    address receiver,\n    string calldata sourcePort,\n    string calldata sourceChannel,\n    uint64 timeoutHeight\n) external {\n    require(_burn(msg.sender, amount));\n\n    _sendPacket(\n        MiniTokenPacketData.Data({\n            amount: amount,\n            sender: abi.encodePacked(msg.sender),\n            receiver: abi.encodePacked(receiver)\n        }),\n        sourcePort,\n        sourceChannel,\n        timeoutHeight\n    );\n}\n")),(0,r.kt)("p",null,"The next step is to implement the Packet registration process ",(0,r.kt)("inlineCode",{parentName:"p"},"_sendPacket"),".\nBy calling ",(0,r.kt)("inlineCode",{parentName:"p"},"IBCHandler.sendPacket"),", the packet to be sent will be registered."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function _sendPacket(\n    MiniTokenPacketData.Data memory data,\n    string memory sourcePort,\n    string memory sourceChannel,\n    uint64 timeoutHeight\n) internal virtual {\n    ibcHandler.sendPacket(\n        sourcePort,\n        sourceChannel,\n        Height.Data({\n            revision_number: 0,\n            revision_height: timeoutHeight\n        }),\n        0,\n        MiniTokenPacketData.encode(data)\n    );\n}\n")),(0,r.kt)("h3",{id:"ibcappbase"},"IBCAppBase"),(0,r.kt)("p",null,"When the IBC Module receives a Channel handshake or a Packet, it needs to be called back to MiniToken.\nIt is convenient to inherit from the abstract contract ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/hyperledger-labs/yui-ibc-solidity/blob/v0.3.14/contracts/apps/commons/IBCAppBase.sol"},"IBCAppBase")," provided by ",(0,r.kt)("inlineCode",{parentName:"p"},"yui-ibc-solidity"),".\nThis implements the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/hyperledger-labs/yui-ibc-solidity/blob/v0.3.14/contracts/core/05-port/IIBCModule.sol"},"IIBCModule")," interface as shown below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"interface IIBCModule {\n    function onChanOpenInit(\n        Channel.Order,\n        string[] calldata connectionHops,\n        string calldata portId,\n        string calldata channelId,\n        ChannelCounterparty.Data calldata counterparty,\n        string calldata version\n    ) external;\n\n    function onChanOpenTry(\n        Channel.Order,\n        string[] calldata connectionHops,\n        string calldata portId,\n        string calldata channelId,\n        ChannelCounterparty.Data calldata counterparty,\n        string calldata version,\n        string calldata counterpartyVersion\n    ) external;\n\n    function onChanOpenAck(string calldata portId, string calldata channelId, string calldata counterpartyVersion) external;\n\n    function onChanOpenConfirm(string calldata portId, string calldata channelId) external;\n\n    function onChanCloseInit(string calldata portId, string calldata channelId) external;\n\n    function onChanCloseConfirm(string calldata portId, string calldata channelId) external;\n\n    function onRecvPacket(Packet.Data calldata, address relayer) external returns (bytes memory);\n\n    function onAcknowledgementPacket(Packet.Data calldata, bytes calldata acknowledgement, address relayer) external;\n\n    function onTimeoutPacket(Packet.Data calldata, address relayer) external;\n}\n")),(0,r.kt)("p",null,"Of the above, token-related processing is mainly handled in the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"onRecvPacket"),(0,r.kt)("li",{parentName:"ul"},"onAcknowledgementPacket")),(0,r.kt)("p",null,"If there is any processing that you want to perform when establishing a channel between ledgers, you will need to implement the following processing. However, we will not handle them speficically in this tutorial:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"onChanOpenInit"),(0,r.kt)("li",{parentName:"ul"},"onChanOpenTry"),(0,r.kt)("li",{parentName:"ul"},"onChanOpenAck"),(0,r.kt)("li",{parentName:"ul"},"onChanOpenConfirm"),(0,r.kt)("li",{parentName:"ul"},"onChanCloseInit"),(0,r.kt)("li",{parentName:"ul"},"onChanCloseConfirm")),(0,r.kt)("p",null,"To handle timeout processes between ledgers, you need to implement the following. However, we will not consider it in this instance:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"onTimeoutPacket")),(0,r.kt)("p",null,"If you want to know more about the lifecycle of a Channel and timeouts in IBC, please refer to the following:"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc/blob/main/spec/core/ics-004-channel-and-packet-semantics/README.md"},"https://github.com/cosmos/ibc/blob/main/spec/core/ics-004-channel-and-packet-semantics/README.md")),(0,r.kt)("h4",{id:"onrecvpacket"},"onRecvPacket"),(0,r.kt)("p",null,"Creates a new token for the specified payee account according to the contents of the Packet."),(0,r.kt)("p",null,"This function is called when a MiniTokenPacketData is received in the token transfer destination ledger."),(0,r.kt)("p",null,"It returns the success or failure of the process as an Acknowledgement."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function onRecvPacket(Packet.Data calldata packet, address relayer) onlyIBC external virtual override returns (bytes memory acknowledgement) {\n    MiniTokenPacketData.Data memory data = MiniTokenPacketData.decode(packet.data);\n    return _newAcknowledgement(\n        _mint(data.receiver.toAddress(), data.amount)\n    );\n}\n")),(0,r.kt)("h4",{id:"onacknowledgementpacket"},"onAcknowledgementPacket"),(0,r.kt)("p",null,"Redeems the token against the originating account if the transaction fails at the destination."),(0,r.kt)("p",null,"This function is called when an Acknowledgement is received in the token transfer source ledger."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function onAcknowledgementPacket(Packet.Data calldata packet, bytes calldata acknowledgement, address relayer) onlyIBC external virtual override {\n    if (!_isSuccessAcknowledgement(acknowledgement)) {\n        _refundTokens(MiniTokenPacketData.decode(packet.data));\n    }\n}\n")),(0,r.kt)("h2",{id:"topics-that-were-not-dealt-with-here"},"Topics that were not dealt with here"),(0,r.kt)("p",null,"The token implemented here is different from ICS-20."),(0,r.kt)("p",null,"For an example of ICS-20 implementation, please refer to the following:"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/hyperledger-labs/yui-ibc-solidity/tree/v0.3.14/contracts/apps"},"https://github.com/hyperledger-labs/yui-ibc-solidity/tree/v0.3.14/contracts/apps")),(0,r.kt)("h3",{id:"distinction-between-currency-units"},"Distinction between currency units"),(0,r.kt)("p",null,"In ICS-20, the denomination or denom is represented as\n",(0,r.kt)("inlineCode",{parentName:"p"},"{ics20Port}/{ics20Channel}/{denom}"),"."),(0,r.kt)("p",null,"Using denom, it is possible to trace an ICS-20 token back to its origin Chain. For more information, please refer to the following:"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/cosmos/ibc-go/blob/main/docs/apps/transfer/overview.md#denomination-trace"},"https://github.com/cosmos/ibc-go/blob/main/docs/apps/transfer/overview.md#denomination-trace")))}p.isMDXComponent=!0}}]);